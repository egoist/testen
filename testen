#!/usr/bin/env node
'use strict'

/**
 * Module dependencies
 */
const fs = require('fs')
const minimist = require('minimist')
const update = require('update-notifier')
const chalk = require('chalk')
const pathExists = require('path-exists')
const figures = require('figures')
const log = require('log-update')
const table = require('text-table')
const co = require('co')
const semver = require('semver')
const exec = require('then-exec')
const arrayUnique = require('array-unique')
const Hinata = require('hinata')
const pkg = require('./package')

const spin = new Hinata({char: 'â™¥', text: '  ', prepend: true})

update({pkg}).notify()

const cli = minimist(process.argv.slice(2), {
	'--': true,
	'alias': {
		n: 'node',
		h: 'help',
		v: 'version',
		V: 'verbose',
		d: 'default'
	}
})
/**
 * Print help
 */
if (cli.help) {
	console.log([
		'',
		'Usage:',
		'',
		'  --node/-n [version]:  Add a node version to test',
		'  --default/-d:         Add preset node versions to test',
		'  -- [command]:         The test command you expect',
		'  --disable-badge:      Disable auto-update testen badge',
		'  --verbose/V:            Always output everything',
		'                          ~ example: there are `console.log` in test',
		''
	].join('\n'))
	process.exit()
}

/**
 * Print version
 */
if (cli.version) {
	console.log(pkg.version)
	process.exit()
}

/**
 * Preset node versions
 */
const presetVersions = [
	'0.12.0',
	'4.2.4',
	'5.6.0'
]

/**
 * Local package.json
 */
let localPkg = {}
if (pathExists.sync(process.cwd() + '/package.json')) {
	localPkg = require(process.cwd() + '/package.json')
}

/**
 * Test script
 */
let testScript = cli['--'].join(' ')
if (!testScript) {
	if (localPkg.testen && localPkg.testen.test) {
		testScript = localPkg.testen.test
	} else {
		testScript = 'npm test'
	}
}

/**
 * Get status form an array of errors
 */
function getStatus(res) {
	let status = 0
	res.every(r => {
		const e = r.error
		if (!e) {
			return false
		}
		if (e.code !== undefined && e.code !== 0) {
			status = e.code
			return false
		}
		return true
	})
	return status
}

/**
 * Update badge
 */
function updateBadge(res) {
	let finalStatus = 0
	if (typeof res === 'number') {
		finalStatus = res
	} else if (Array.isArray(res)) {
		finalStatus = getStatus(res)
	}
	if (!cli['disable-badge'] && pathExists.sync('./README.md')) {
		const badge = finalStatus === 0 ?
			'https://img.shields.io/badge/testen-passing-brightgreen.svg' :
			'https://img.shields.io/badge/testen-failed-red.svg'
		let content = fs.readFileSync('./README.md', 'utf8')
		content = content.replace(
			/!\[testen badge\]\(.*\)/,
			`![testen badge](${badge})`
		)
		fs.writeFileSync('./README.md', content, 'utf8')
	}
	spin.stop()
	process.exit(finalStatus)
}

co(function* main () {
	/**
	 * Get default node version
	 */
	const getDefaultNodeVersion = yield exec('node -v')
	const defaultNodeVersion = getDefaultNodeVersion.stdout.substring(1).trim()

	/**
	 * Get input node versions and sort them
	 */
	let nodeVersions = cli.node
	if (!nodeVersions) {
		const pkgNodeVersion = localPkg.testen && localPkg.testen.node
		if (pkgNodeVersion && pkgNodeVersion.length > 0) {
			nodeVersions = pkgNodeVersion
		} else {
			nodeVersions = [defaultNodeVersion]
		}
	}
	if (typeof nodeVersions === 'string') {
		nodeVersions = [nodeVersions]
	}
	if (cli.default) {
		nodeVersions = nodeVersions.concat(presetVersions)
	}
	nodeVersions = arrayUnique(nodeVersions)
	nodeVersions.sort((a, b) => semver.gt(a, b))

	const spinLength = nodeVersions.length
	spin.length = spinLength
	spin.start()

	/**
	 * Generate initial result and log as table
	 */
	const result = nodeVersions.map(v => {
		return ['  ' + chalk.gray(figures.circle), v, chalk.gray('running')]
	})
	log('\n' + table(result) + '\n')

	/**
	 * Execute test
	 */
	let msg = []
	const execTest = co.wrap(function* (command, index) {
		const cmd = yield exec(command)
		result[index] = [
			'  ' + (cmd.error ? chalk.red(figures.cross) : chalk.green(figures.tick)),
			nodeVersions[index],
			cmd.error ? chalk.red('failed') : chalk.green('success')
		]
		if (cmd && (cmd.error || cli.verbose)) {
			let output = cmd.stdout.toString().split('\n')
			output[0] = chalk.bold(output[0])
			if (!output[1] && !cmd.error) {
				output[1] = 'no output\n'
			}
			output = output.join('\n')
			msg[index] = `${output.trim()}${cmd.error ? `${cmd.error.message.trim()}` : ''}`
		}
		let heading = `${msg.join('\n\n')}\n`
		if (heading.trim()) {
			heading += '\n'
		}
		log(heading + table(result) + '\n')
		return cmd
	})

	/**
	 * Running test for each version of node
	 */
	const res = yield nodeVersions.map((v, index) => {
		return execTest(`. ~/.nvm/nvm.sh && nvm exec ${v} ${testScript}`, index)
	})

	updateBadge(res)
}).catch(e => {
	log.clear()
	console.log(e.stack)
	updateBadge(1)
})
